先看这道题：[19.删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)。

> 给你一个链表，删除链表的倒数第  n  个结点，并且返回链表的头结点。
>
> 示例 1：
>
> ```
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> ```

之前说过，链表不能直接知道一共有多少个元素，所以不能直接操作。在这道[重排链表](https://github.com/Lzzzzzzy/goodbye-algorithm/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/3.%E9%93%BE%E8%A1%A8/3.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.md)题里我们用到了双指针，只不过是用双指针来寻找链表中点。这道题需要找倒数第 N 个节点，同样想象一个场景：

两个人从同一个地点出发，一个人先走 5 公里，另一个才从起点出发，两个人以同样的速度走，当第一个人到达终点时，第二个人是不是刚好距离终点 5 公里？

所以这道题就需要让第一个指针先走 N 步，等它到达终点时，第二个指针和终点的距离刚好为 N。看图。

- [ ] 此处应有图

当找到第 N 个节点之后，就只需要把这个节点的 next 指针指向更后面的节点就可以了。

根据以上思路，我们可以写出代码：

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        slow, fast = head, head

        # 让快指针先走n步
        for i in range(n):
            fast = fast.next

        # 慢指针和快指针用同样的速度走到终点
        while fast.next:
            fast = fast.next
            slow = slow.next

        # 慢指针指向的节点跳过下一个节点
        slow.next = slow.next.next
        return head
```

但是这样写有一个小 bug，就是当题目中要删除链表的头节点时，代码是执行不过去的。因为 `slow` 指向了 head，但跳过节点我们用了 `slow.next = slow.next.next`，所以这个头节点是肯定不会被删除的。

这时候就要用到链表的「虚拟头结点」技巧了，在原链表的头部加一个节点，就能保证 `slow` 永远有节点可以跳过，像这样：

- [ ] 此处有图

所以改一下我们的代码：

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # 加一个虚拟头节点
        new_head = ListNode(next=head)
        slow, fast = new_head, new_head

        # 因为多加了一个头节点, 所以让快指针走n+1步
        for i in range(n + 1):
            fast = fast.next

        # 慢指针和快指针用同样的速度走到终点，因为多加了一个头结点，所以慢指针也要多走一步
        while fast:
            fast = fast.next
            slow = slow.next

        # 慢指针指向的节点跳过下一个节点
        slow.next = slow.next.next
        return new_head.next
```

大功告成，下课！
