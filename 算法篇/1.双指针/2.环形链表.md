来看链表里一个非常经典的题目：[141.环形链表](https://leetcode.cn/problems/linked-list-cycle/)。

> 给你一个链表的头节点 head ，判断链表中是否有环。
>
> 如果链表中存在环  ，则返回 true 。 否则，返回 false 。
>
> 示例 1：
>
> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：true
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```

因为链表会保存下一个节点的位置，所以在一个单链表中就可以在尾部节点再保存下一个节点，这样就会形成一个环。

如果形成了环，那么必然会走回头路。就像跑 1000 米，你跑的太慢，跑得快的人就会超你一圈。同样的，如果跑的快的指针超过了跑得慢的指针，那就说明是环形的。

这里我们用快慢指针实现：

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head:
            return False
        slow, fast = head, head
        while fast.next and fast.next.next:  # 如果没到终点就一直跑
            fast = fast.next.next
            slow = slow.next

            if slow == fast:  # 快慢指针相遇说明有环
                return True
        return False
```

这道题很简单，接下来的题在这道题上做了一点修改，[142.环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)：

> 给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回  `null`。*
>
> 示例 1：
>
> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：返回索引为 1 的链表节点
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```

首先还是需要判断列表是否有环，如果没环就返回 null。

把判断有环的代码改改：

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None  # 没环返回None
        slow, fast = head, head
        while fast.next and fast.next.next:  # 如果没到终点就一直跑
            fast = fast.next.next
            slow = slow.next

            if slow == fast:  # 快慢指针相遇说明有环,需要判断环的第一个节点
                pass
        return None  # 没环返回None
```

现在的问题就是怎么找到环的第一个节点呢？当快慢指针相遇时，把快指针挪回链表开头，在让快慢指针一起，每次只走 1 步，相遇的点就是环的入口了。这里的数学证明超过了小学数学的范畴，直接上图吧：

- [ ] 此处有图

看不懂也没关系，这里只用记住就可以了。

所以修改我们的代码：

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None
        slow, fast = head, head
        while fast.next and fast.next.next:  # 如果没到终点就一直跑
            fast = fast.next.next
            slow = slow.next

            if slow == fast:  # 快慢指针相遇说明有环,需要判断环的第一个节点
                break

        if not fast.next or not fast.next.next:  # 快指针到终点了说明没环，返回None
            return None

        fast = head  # 快指针移到起点，快慢指针一起动
        while slow != fast:
            fast = fast.next
            slow = slow.next
        return slow
```

这两道链表题也是用了快慢指针的方法，可以看到链表使用快慢指针的情况是很多的。
