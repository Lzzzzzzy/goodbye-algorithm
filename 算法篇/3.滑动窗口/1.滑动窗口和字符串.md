字符串是滑动窗口的应用大户，leetcode 第 3 题就是这样一道滑动窗口题，[3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/):

[longest-substring-without-repeating-characters]()

要找最长子串，可以用左右指针指向`str[0]`，当遇到不重复的字符时，右指针向右移动；当遇到重复字符时，左指针向右移动，直到没有重复字符。结束条件就是右指针走到最后一个字符。用图表示：

- [ ] 此处有图

写成代码：

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 字符串长度<2时肯定不会重复
        if len(s) < 2:
            return len(s)

        # 左右指针指向字符串开头
        left, right = 0, 0

        # 保存窗口内的字符出现次数
        window = {}

        # 保存无重复子串长度
        longest = 0
        while right < len(s):
            # 保存窗口内字符次数
            char = s[right]
            if window.get(char):
                window[char] += 1
            else:
                window[char] = 1
            right += 1

            # 出现重复字符,左指针向右移动,直到没有重复字符
            while window[char] > 1:
                window[s[left]] -= 1
                left += 1

            longest = max(longest, right - left)
        return longest
```

还有这道[76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)：

[minimum-window-substring]()

思路差不多，先移动右侧指针，当窗口内的字符满足要对比的字符串`t`时，再移动左侧指针，来寻找最小覆盖的子串。

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if len(s) < len(t) or not len(s):
            return ""

        need = {}  # 记录标准字符串中各字符出现的次数
        for char in t:
            if need.get(char):
                need[char] += 1
            else:
                need[char] = 1

        left, right = 0, 0  # 左右指针指向字符串开头
        window = {}  # 记录窗口内元素
        valid_char = 0  # 记录符合匹配字符的个数
        start, length = 0, len(s) + 1  # 记录起始位置和字符串长度
        while right < len(s):
            # 如果右指针指向的字符在need中就加入窗口中记录
            char_right = s[right]
            right += 1
            if char_right in need:
                if char_right in window:
                    window[char_right] += 1
                else:
                    window[char_right] = 1

                # 如果window里的字符出现次数和need里一样,说明这个字符已经符合要求了
                if window[char_right] == need[char_right]:
                    valid_char += 1

            # 找到最长的合法子串后开始缩小左侧边界,直到字符串不合法,这时候就找到最短子串了
            while valid_char == len(need):
                # 和之前得到的最短子串对比,保证最终得到的子串最短
                if right - left < length:
                    start = left
                    length = right - left

                char_left = s[left]
                if char_left in need:
                    if window[char_left] == need[char_left]:
                        valid_char -= 1
                    window[char_left] -= 1
                left += 1
        return "" if length > len(s) else s[start : start+length]
```

通过这两道题，我们可以总结出来一个滑动窗口的代码模板：

```python
def sliding_window(s: str):
    left, right = 0, 0  # 左右指针都指向开头位置
    window = {}  # 记录窗口内的字符出现次数
    while right < len(s):
        # 把右指针指向的字符加入到窗口中
        char_right = s[right]
        if char_right in window:
            window[char_right] += 1
        else:
            window[char_right] = 1
        # 进入窗口后要做什么
        # pass

        # 增大窗口
        right += 1

        # 缩小窗口
        while 窗口收缩条件：
            char_left = s[left]
            window[char_left] -= 1
            # 从窗口里移除之后要做什么
            # pass
            left += 1
```

滑动窗口其实很简单，主要就是要考虑清楚以下几点：

1. 增大右侧窗口要做什么

2. 什么时候需要收缩左侧窗口

3. 收缩窗口后要做什么

以上就是滑动窗口的要点。只要想清楚这几点，用滑动窗口来处理子串、子序列问题就没问题了。
