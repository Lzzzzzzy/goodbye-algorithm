又到了喜闻乐见的「融会贯通」环节，来看这道披着数学皮的算法题：[车队](https://leetcode.cn/problems/car-fleet/)。

> 在一条单行道上，有 n 辆车开往同一目的地。目的地是几英里以外的  target 。
>
> 给定两个整数数组  position  和  speed ，长度都是 n ，其中  position[i]  是第 i 辆车的位置， speed[i]  是第 i 辆车的速度(单位是英里/小时)。
>
> 一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车 以相同的速度紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。
>
> 车队   是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。
>
> 即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。
>
> 返回到达目的地的 车队数量 。
>
> 示例 1：
>
> ```
> 输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
> 输出：3
> 解释：
> 从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。
> 从 0 处开始的车无法追上其它车，所以它自己就是一个车队。
> 从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。
> 请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。
> ```
>
> 示例 2:
>
> ```
> 输入: target = 100, position = [0,2,4], speed = [4,2,1]
> 输出: 1
> 解释:
> 以0(速度4)和2(速度2)出发的车辆组成车队，在4点相遇。舰队以2的速度前进。
> 然后，车队(速度2)和以4(速度1)出发的汽车组成一个车队，在6点相遇。舰队以1的速度前进，直到到达目标。
> ```

题目看完，我直接晕了。描述的太复杂了，我来简化一下：有 n 辆车，到终点的距离不同，车辆行驶速度不同，问一共会分几批车到达终点？（车辆相遇后会以最慢的那辆车的速度行驶）

看这题目有没有一种做初中数学应用题的感觉？其实这道题的难点就是怎么判断车辆会相遇。

我们先把车降到 2 辆，看这个例子：

```
target = 12, position = [5,3], speed = [1,3]
```

其中第 1 辆车和终点距离为 7，每小时跑 1，那么到达终点的时间为 7。第 2 辆车距离终点的距离为 9，每小时跑 3，到达终点的时间为 3。因为 3<7，所以这两辆车必然会相遇。

ok，再加一辆车：

```
target = 12, position = [0,5,3], speed = [1,1,3]
```

按刚才的方式分析，新加进来的车到达终点的时间是 12，那他会不会被追上呢？

答案是不会，因为他距离终点最远，后面没有车追它，所以他必然不会和别人组成车队。

我们把 position 排个序，就能看的更直观，当然 speed 也要跟着变：

```
target = 12, position = [5,3,0], speed = [1,3,1]
```

为了看后面有没有车能追上前面的车，对 position 按照从大到小的顺序排列一下就更好判断了对吧？而且刚才分析两车相遇的条件就是后面的车到达终点的时间要 **小于等于**前面的车到终点的时间。

要判断一共会分几批到达终点，就可以用到栈了。还是用上面的例子：

第一辆车到终点的时间是 7，入栈：

```python
stack = [7]
```

第二辆车到终点的时间是 3，入栈：

```python
stack = [7, 3]
```

题目说过，车辆相遇后会以最慢的那辆车的速度行驶，所以他们到达终点的时间，就等于跑的最慢的那辆车到终点的时间，也就是 7，他俩会一起到，3<7，3 不应该入栈。

```python
stack = [7]
```

第三辆车到终点的时间是 12，12>7，入栈：

```python
stack = [7, 12]
```

看到了吗，最后 stack 里元素的数量就是最终会分几批到。

好了，思路有了，上代码：

```python
class Solution:
    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
        pair = [[p, s] for p, s in zip(position, speed)]
        pair.sort(reverse=True)  # 对 position 按照从大到小的顺序排列,越大离终点越近
        stack = []
        for p, s in pair:
            time = (target - p) / s  # 到达终点的时间
            if not stack or time > stack[-1]:  # 如果后面的车追不上前面的车,就入栈
                stack.append(time)
        return len(stack)
```

收藏永不停止，行动现在开始！
